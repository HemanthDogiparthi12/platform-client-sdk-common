import fs from 'fs';
import path from 'path';

function basicHashModulo(inputStr: string, modulo: number): number {
    var hashValue = 0;
    for (var i = 0; i < inputStr.length; i++) {
        var charCode = inputStr.charCodeAt(i);
        hashValue += charCode;
    }
    return hashValue % modulo;
}

export default class CombineModels {

	aggregatedModelFiles: Map<string, string>;
	dirent: fs.Dirent;

	combineApiModelFiles(modelsDir: string, aggregatedFileNamePrefix: string, aggregateModels: boolean, aggregateModulo: number) {
		// aggregateModulo: 1 (1 single model file), > 1 (compute hash/modulo per model and distribute in x model files)

		if (aggregateModels == true) {
			this.aggregatedModelFiles = new Map<string, string>();
			if (aggregateModulo > 0 && aggregateModulo < 101) {
				// Concatenate new file with former one:
				const baseFile = '\/\/\n\/\/ Generated by swagger-codegen\n\/\/ https:\/\/github.com\/swagger-api\/swagger-codegen\n\/\/\n\nimport Foundation\n';
				for (var indexFile = 1; indexFile <= aggregateModulo; indexFile++) {
					this.aggregatedModelFiles.set(indexFile.toString(), baseFile);
				}
			} else {
				console.log('Modulo must be between 1 and 100');
				process.exit(-1);
			}
		}
		const dir = fs.opendirSync(modelsDir);

		try {
			// Read docs dir to find swaggerTag category API data
			while ((this.dirent = dir.readSync()) !== null) {
				const modelFilePath = path.join(modelsDir, this.dirent.name);
				let modelFileTextContent = fs.readFileSync(modelFilePath, 'utf8');

				// Ignore files containing "TAG-REMOVE-MODEL-FILE"
				// These corresponds to type:object Models - mapped with JSON type alias - to be ignored/removed
				if (modelFileTextContent.includes('TAG-REMOVE-MODEL-FILE')) {
					// delete model file (even if no aggregation)
					fs.unlinkSync(modelFilePath);
				} else {
					if (aggregateModels == true) {
						if (aggregateModulo == 1) {
							// Concatenate new file with former one:
							let newAggregatedModel = this.aggregatedModelFiles.get(aggregateModulo.toString()) + '\n' + modelFileTextContent;
							this.aggregatedModelFiles.set(aggregateModulo.toString(), newAggregatedModel);
						} else if (aggregateModulo > 1) {
							let modelIndex = basicHashModulo(this.dirent.name, aggregateModulo);
							// Add 1 to start index at 1
							modelIndex++;
							let newAggregatedModel = this.aggregatedModelFiles.get(modelIndex.toString()) + '\n' + modelFileTextContent;
							this.aggregatedModelFiles.set(modelIndex.toString(), newAggregatedModel);
						}

						// Delete source file
						fs.unlinkSync(modelFilePath);
					}
				}
			}

			dir.closeSync();

			if (aggregateModels == true) {
				// Write aggregated output
				if (aggregateModulo == 1) {
					fs.writeFileSync(`${aggregatedFileNamePrefix}.swift`, this.aggregatedModelFiles.get(aggregateModulo.toString()));
				} else if (aggregateModulo > 1) {
					for (var indexFile = 1; indexFile <= aggregateModulo; indexFile++) {
						fs.writeFileSync(`${aggregatedFileNamePrefix}P${indexFile.toString()}.swift`, this.aggregatedModelFiles.get(indexFile.toString()));
					}
				}
			}
		} catch (err) {
			console.log(err);
			process.exit(-1);
		}

	}

}

const combineModels = new CombineModels();
const modelsDir = process.argv[2];
const aggregatedFileNamePrefix = process.argv[3];
const aggregateModels = process.argv[4];
const aggregateModulo = process.argv[5];
combineModels.combineApiModelFiles(modelsDir, aggregatedFileNamePrefix, (aggregateModels.toLowerCase() === "true"), parseInt(aggregateModulo));